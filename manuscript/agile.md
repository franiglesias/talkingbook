# Qué es y que no es agile

Agile no es una metodología, ni un proceso, ni un framework. Creo que hasta es incorrecto decir que es una mentalidad o _mindset_. Quizá podríamos decir que agile es una forma de reflexionar sobre el desarrollo de software, o una filosofía, si lo prefieres.

Históricamente, podemos pensar que Agile nace con el Manifiesto Agile, pero más bien el Manifiesto es un punto de encuentro para diversos grupos y profesionales preexistentes que habían desarrollado sus propias metodologías y frameworks, como _extreme programming_, _scrum_, _lean_, incluso _DevOps_ podría considerarse agile. Muchos de estos frameworks están inspirados u obtienen ideas de las metodologías _Lean Manufacturing_ o el _Toyota Production System_.

¿Por qué? Pues porque los equipos de desarrollo de software entendieron que las metodologías clásicas de la ingeniería no funcionaban bien aplicadas al software. 

Por lo general, la ingeniería física require un diseño meticuloso y una planificación cuidadosa antes de comenzar a implementar. No puedes empezar a construir un puente sin saber donde vas a poner los pilares, qué hay al otro lado, cómo se va a usar, qué peso va a tener que soportar, qué fuerzas pueden influir sobre él, como corrientes de agua o vientos, y un largo etcétera.

En muchos sentidos, la ingeniería física crea productos que han de acertar a la primera. Pero al requerir mucho tiempo de desarrollo y ejecución, es muy posible que cuando por fin han sido desplegados pueden haber ocurrido cambios en el entorno a los que ya no se puede adaptar. 

Pero el software no tiene los mismos condicionantes. En comparación con cualquier ingeniería física, que trabaja con materiales sujetos a las leyes de la naturaleza, el software es mucho más libre. Puedes usar el software a medida que se construye, una vez que hay suficientes elementos desplegados. Incluso aunque esté incompleto puede proporcionar un valor. Por otro lado, es relativamente fácil de cambiar, lo que permite reaccionar cuando vemos que el negocio va cambiando de maneras que no habíamos previsto.

Para ello son fundamentales los ciclos de feedback, es decir, la información que obtenemos sobre el comportamiento del software de diversas fuentes. Cuanto más cortos, mejor. Y por cortos entendemos minutos mejor que horas, horas mejor que días y así sucesivamente. Para lograrlo necesitamos incorporar, por un lado, a la cliente o usuaria en el equipo de desarrollo de forma que podamos tener conversaciones con ella cada vez que sea necesario. Por otro lado, incorporamos prácticas que nos faciliten el feedback, como _pair-programming_, test driven development, etc. Pero también implica entregar el software en pequeños lotes de funcionalidad, de tal modo que revertir lo desplegado o introducir cambios sea lo menos costoso posible.

Esta forma de abordar los proyectos de software puede parecer idílica, pero es factible. 

Lo primero que hay que tener en cuenta es que no es algo que se pueda conseguir de la noche a la mañana. Requiere un proceso de aprendizaje. Requiere hacerse consciente de como trabajas y reflexionar sobre cómo mejorar esa forma de trabajar. Por tanto, requiere una cierta capacidad de autocrítica, individual y grupal.

Es decir: un equipo no se vuelve agile porque le adjudiquemos la etiqueta, o por introducir una serie de prácticas descontextualizadamente. En vez de eso, un equipo aprende a trabajar de forma agile a medida que desarrolla un proyecto.

No existe una receta para ser agile salvo aplicar, quizá, los principios del Manifiesto. Por otro lado, disponemos de frameworks como Scrum, Extreme Programming, Kanban y otros menos conocidos.

Si el manifesto te parece demasiado largo, quédate con esta definición de Allen Holub:

Agile:

* Trabajad en lotes pequeños
* Hablad entre vosotras
* Mejorad la vida de la gente

Esto es todo. Todo lo demás es basura y distracciones.
